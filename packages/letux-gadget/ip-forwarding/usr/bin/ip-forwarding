#! /bin/bash
#
# configure Linux or macOS host for tethering with an Letux device connected through ethernet over USB (RNDIS/NCM ethernet gadget)
#
# it uses the current service or default route for internet connection
#
# on Mac the device is identified by its IP address
# on Linux the device is (currently) assumed to create ifconfig usb0 or an interface passed as $1
#

DEVICE=192.168.0.202	# Letux device

case "$0" in
	/* )
		SCRIPTPATH="$0"
		;;
	./* )
		SCRIPTPATH="$PWD/$0"
		;;
	* )	# should search in $PATH
		echo "can't install $0";
		exit 1
		;;
esac

echo "+++ running $SCRIPTPATH"
date

darwin() {
# based on
# http://apple.stackexchange.com/questions/228936/using-server-5-0-15-to-share-internet-without-internet-sharing
# https://superuser.com/questions/931827/sharing-openvpn-on-mac-os-x-yosemite

# locate highest priority active service
# found at https://apple.stackexchange.com/questions/191879/how-to-find-the-currently-connected-network-service-from-the-command-line
# and improved...
# active VPN (utun) hides highest priority active network so we check first

CURRENT=""
INTERFACE=""

while read LINE
do
	NAME=$(echo $LINE | awk -F  "(, )|(: )|[)]" '{print $2}')
	DEV=$(echo $LINE | awk -F  "(, )|(: )|[)]" '{print $4}')
# echo "Current service: $NAME, $DEV, $CURRENT, $INTERFACE"
	if [ "$DEV" ]
	then
		case "$NAME" in utun* )
			if ifconfig "$DEV" 2>/dev/null | grep -q 'status: active'
			then
				CURRENT="$NAME"
				INTERFACE="$DEV"
				break 2	# take first we find
			fi
		esac
	fi
done < <(networksetup -listnetworkserviceorder | grep 'Hardware Port')

echo "$INTERFACE"

if [ ! "$INTERFACE" ]	# no VPN found
then

	while read LINE
	do
		NAME=$(echo $LINE | awk -F  "(, )|(: )|[)]" '{print $2}')
		DEV=$(echo $LINE | awk -F  "(, )|(: )|[)]" '{print $4}')
# echo "Current service: $NAME, $DEV, $CURRENT, $INTERFACE"
		if [ "$DEV" ]
		then
			if ifconfig "$DEV" 2>/dev/null | grep -q 'status: active'
			then
				CURRENT="$NAME"
				INTERFACE="$DEV"
# echo "found: $NAME, $DEV, $CURRENT, $INTERFACE"
				break 2	# take first we find
			fi
		fi
	done < <(networksetup -listnetworkserviceorder | grep 'Hardware Port')

fi

# echo "found: $NAME, $DEV, $CURRENT, $INTERFACE"

if [ ! "$CURRENT" ]
then
	echo "Could not identify current internet service on your host" >&2
	exit 1
fi
echo Sharing $DEVICE over: $CURRENT $INTERFACE

echo "(NOTE: ignore messages about ALTQ)"
sudo pfctl -F nat

echo "nat log on $INTERFACE from $DEVICE to any -> ($INTERFACE)"
#nat log on en0 from $DEVICE to any -> (en0)" | sudo pfctl -N -f - -e
echo "(NOTE: ignore messages about -f option flushing rules)"
echo "nat log on $INTERFACE from $DEVICE to any -> ($INTERFACE)" | sudo pfctl -N -f - -e
sudo pfctl -a '*' -s nat

echo "sysctl (one of these should succeed)"	# FIXME: we could make this depend on $(uname -r)
sudo sysctl -w net.inet.ip.forwarding=1
sudo sysctl -w net.inet.ip.fw.enable=1 || echo "may fail on newer macOS kernels (can be ignored)."
# sudo sysctl -w net.inet6.ip6.forwarding=1

## logging
# ifconfig pflog1 create
# sudo tcpdump -n -e -ttt -i pflog1
# sudo tcpdump -n -e -ttt -i $INTERFACE
}

linux() {
# based on http://jpdelacroix.com/tutorials/sharing-internet-beaglebone-black.html

HOST=192.168.0.200	# fixme: somehow find out or calculate...

USB=$1	# passed in from the udev rule - default to usb0 if there is no rule
[ "$USB" ] || USB=$(ifconfig -a | fgrep ncm | cut -d ':' -f 1)
[ "$USB" ] || USB=$(ifconfig -a | fgrep usb | cut -d ':' -f 1)

if [ ! "$USB" ]
then
	echo "Could not find incoming interface" >&2
	exit 1
fi

INTERFACE=$(route | grep '^default' | head -1 | grep -o '[^ ]*$')	# first default outgoing route

if [ ! "$INTERFACE" ]
then
	echo "Could not find current internet service interface" >&2
	exit 1
fi

echo Sharing $DEVICE at $USB over $INTERFACE

ifconfig $USB $HOST
sysctl net.ipv4.ip_forward=1
iptables --table nat --append POSTROUTING --out-interface $INTERFACE -j MASQUERADE
iptables --append FORWARD --in-interface $USB -j ACCEPT
}

case "$(uname -s)" in
Darwin )
	darwin;;
Linux )
	linux $1	# $1 is available from udev rule
* )
	echo unknown operating system $(uname -a)
	;;
esac
